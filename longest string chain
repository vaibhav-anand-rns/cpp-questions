#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> dp; // memoization

    // Check if a is a predecessor of b
    bool isPredecessor(string &a, string &b) {
        if (b.size() != a.size() + 1) return false;
        int i = 0, j = 0;
        while (i < a.size() && j < b.size()) {
            if (a[i] == b[j]) {
                i++; j++;
            } else {
                j++; // skip one char in b
            }
        }
        return (i == a.size());
    }

    // dfs(i) -> longest chain ending at words[i]
    int dfs(int i, vector<string>& words) {
        if (dp[i] != -1) return dp[i];

        int best = 1; // at least the word itself
        for (int j = 0; j < i; j++) {
            if (isPredecessor(words[j], words[i])) {
                best = max(best, 1 + dfs(j, words));
            }
        }
        return dp[i] = best;
    }

    int longestStrChain(vector<string>& words) {
        int n = words.size();

        // Sort words by length
        sort(words.begin(), words.end(), [](string &s1, string &s2) {
            return s1.size() < s2.size();
        });

        dp.assign(n, -1);
        int ans = 1;
        for (int i = 0; i < n; i++) {
            ans = max(ans, dfs(i, words));
        }
        return ans;
    }
};

int main() {
    Solution sol;
    vector<string> words = {"a","b","ba","bca","bda","bdca"};
    cout << sol.longestStrChain(words) << endl; // Output: 4
    return 0;
}
