class solution{
    
    public:
           
           ListNode* reverse(ListNode* head){
               
               ListNode*prev = null;
               ListNode*curr = head;
               ListNode**nxt = null;
               
               while(curr){
                   
                   nxt = curr->next;
                   curr->next = prev;
                   prev = curr;
                   curr = next
               }
               return prev;
           }
           
            void reorderList(ListNode* head){
                
                
                //step 1 - using slow and fast pointer approach to find the mid of the list
                
                ListNode*slow = head;
                ListNode*fast = head->next;
                while(fast && fast->next){
                    
                    slow = slow->next;
                    fast = fast->next->next;
                    
                }
                 //step 2 - reverse the second half and split the List into two.
                 
                 ListNode*second = reverse(slow->next);
                 slow->next = null;
                 ListNode*first = head;
            }
            
             //step 3 - merging the two list
        // second list can be shorter when LL size is odd
        
           while(second){
               
               
               ListNode*temp1 = first->next;
               ListNode*temp2 = second->next;
               first->next = second;
               second->next = temp1;
               first = temp1;
               second = temp2;
               
               
               
               
               
               
               
               
               
               
           }
           
}
